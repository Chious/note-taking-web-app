# Task ID: 2
# Title: Database Schema and Prisma ORM Setup (with OAuth + Edit History Support)
# Status: pending
# Dependencies: 1
# Priority: high
# Description: Set up PostgreSQL database schema using Prisma ORM with User, Notes, NoteHistory models, and NextAuth OAuth models as specified in the PRD
# Details:
1. Install Prisma:
```bash
npm install prisma @prisma/client
npx prisma init
```
2. Configure database connection in .env file:
```
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/noteapp?schema=public"
```
3. Define Prisma schema in schema.prisma:
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String        @id @default(cuid())
  email         String        @unique
  password      String?       // nullable for OAuth users
  name          String?
  image         String?
  provider      String        @default("email")
  providerId    String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  notes         Note[]
  noteHistory   NoteHistory[]
  
  // NextAuth required fields
  accounts      Account[]
  sessions      Session[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Note {
  id         String        @id @default(cuid())
  userId     String
  title      String
  content    String        @db.Text
  tags       String[]
  isArchived Boolean       @default(false)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  lastEdited DateTime      @default(now())
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  history    NoteHistory[]
}

model NoteHistory {
  id         String   @id @default(cuid())
  noteId     String
  userId     String
  title      String
  content    String   @db.Text
  tags       String[]
  version    Int      @default(autoincrement())
  changeType String   // 'create', 'update', 'title_change', 'content_change', 'tags_change'
  createdAt  DateTime @default(now())
  note       Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([noteId, version])
  @@index([userId, createdAt])
}
```
4. Create initial migration:
```bash
npx prisma migrate dev --name init
```
5. Generate Prisma client:
```bash
npx prisma generate
```
6. Create a database service file at lib/db.ts:
```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma = globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
```

# Test Strategy:
1. Verify Prisma schema matches the requirements in the PRD
2. Test database connection using Prisma Studio
3. Create test records and verify relationships between User and Notes
4. Validate constraints like unique email and foreign key relationships
5. Test migration rollback and reapplication
6. Verify NextAuth OAuth models work correctly with Google authentication
7. Test user creation through both email/password and Google OAuth flows
8. Validate account linking for users with same email from different providers
