{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Configuration",
        "description": "Initialize Next.js project with TypeScript, Tailwind CSS, and configure development environment with Docker Compose",
        "details": "1. Create a new Next.js project with TypeScript support:\n```bash\nnpx create-next-app@latest note-app --typescript\n```\n2. Install and configure Tailwind CSS:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n3. Configure Tailwind CSS in tailwind.config.js and globals.css\n4. Set up ESLint and Prettier:\n```bash\nnpm install -D eslint prettier eslint-config-prettier\n```\n5. Create Docker Compose configuration for development:\n```yaml\nversion: '3'\nservices:\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    ports:\n      - '3000:3000'\n    volumes:\n      - .:/app\n    depends_on:\n      - db\n  db:\n    image: postgres:14\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: postgres\n      POSTGRES_DB: noteapp\n    ports:\n      - '5432:5432'\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\nvolumes:\n  postgres_data:\n```\n6. Create Dockerfile.dev for development\n7. Set up GitHub Actions for CI/CD in .github/workflows/ci.yml\n8. Configure Vitest for testing:\n```bash\nnpm install -D vitest @testing-library/react @testing-library/jest-dom\n```",
        "testStrategy": "1. Verify Next.js application builds successfully\n2. Confirm Tailwind CSS is properly configured by testing a sample component\n3. Validate Docker Compose setup by running the development environment\n4. Test ESLint and Prettier configurations with sample code\n5. Verify GitHub Actions workflow by pushing a test commit",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Database Schema and Prisma ORM Setup",
        "description": "Set up Cloudflare D1 (SQLite) database schema using Prisma ORM with User and Notes models as specified in the PRD",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Install Prisma:\n```bash\nnpm install prisma @prisma/client\nnpx prisma init\n```\n2. Configure database connection in .env file for D1:\n```\nDATABASE_URL=\"file:./dev.db\"\n```\n3. Define Prisma schema in schema.prisma for D1 (SQLite):\n```prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  password  String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  notes     Note[]\n}\n\nmodel Note {\n  id         String   @id @default(cuid())\n  userId     String\n  title      String\n  content    String\n  tags       String\n  isArchived Boolean  @default(false)\n  createdAt  DateTime @default(now())\n  updatedAt  DateTime @updatedAt\n  lastEdited DateTime @default(now())\n  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n```\n4. Create initial migration:\n```bash\nnpx prisma migrate dev --name init\n```\n5. Generate Prisma client:\n```bash\nnpx prisma generate\n```\n6. Create a database service file at lib/db.ts:\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma = globalForPrisma.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n\nexport default prisma;\n```\n7. Configure Cloudflare D1 binding in wrangler.toml:\n```toml\n[[d1_databases]]\nname = \"noteapp\"\ndatabase_name = \"noteapp\"\ndatabase_id = \"<your-d1-database-id>\"\n```\n8. Create a D1 database using Cloudflare Wrangler CLI:\n```bash\nnpx wrangler d1 create noteapp\n```\n9. Update the Note model's tags field to handle SQLite limitations with arrays:\n   - SQLite doesn't natively support arrays, so store tags as a comma-separated string",
        "testStrategy": "1. Verify Prisma schema matches the requirements in the PRD and is compatible with SQLite\n2. Test database connection using Prisma Studio with the local SQLite database\n3. Create test records and verify relationships between User and Notes\n4. Validate constraints like unique email and foreign key relationships\n5. Test migration rollback and reapplication\n6. Test Cloudflare D1 connection in development environment\n7. Verify data persistence in the D1 database\n8. Test the tags implementation as a string with comma separation\n9. Validate that the database works correctly when deployed to Cloudflare Workers/Pages",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure Prisma for SQLite/D1",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create D1 database in Cloudflare",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Configure Cloudflare D1 bindings in wrangler.toml",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Adapt schema for SQLite limitations (array handling)",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Test database operations in local development",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Test database operations in Cloudflare environment",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Authentication System Implementation",
        "description": "Implement user registration, login, and JWT-based authentication with protected routes",
        "details": "1. Install required packages:\n```bash\nnpm install bcryptjs jsonwebtoken zod next-auth\nnpm install -D @types/bcryptjs @types/jsonwebtoken\n```\n2. Create authentication utilities in lib/auth.ts:\n```typescript\nimport { compare, hash } from 'bcryptjs';\nimport { sign, verify } from 'jsonwebtoken';\n\nexport async function hashPassword(password: string): Promise<string> {\n  return hash(password, 12);\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return compare(password, hashedPassword);\n}\n\nexport function generateToken(userId: string): string {\n  return sign({ userId }, process.env.JWT_SECRET!, { expiresIn: '7d' });\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return verify(token, process.env.JWT_SECRET!) as { userId: string };\n  } catch (error) {\n    return null;\n  }\n}\n```\n3. Create registration API endpoint at app/api/register/route.ts:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport prisma from '@/lib/db';\nimport { hashPassword } from '@/lib/auth';\n\nconst registerSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n});\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { email, password } = registerSchema.parse(body);\n    \n    const existingUser = await prisma.user.findUnique({ where: { email } });\n    if (existingUser) {\n      return NextResponse.json({ error: 'Email already in use' }, { status: 400 });\n    }\n    \n    const hashedPassword = await hashPassword(password);\n    const user = await prisma.user.create({\n      data: { email, password: hashedPassword },\n    });\n    \n    return NextResponse.json({ id: user.id, email: user.email }, { status: 201 });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json({ error: error.errors }, { status: 400 });\n    }\n    return NextResponse.json({ error: 'Registration failed' }, { status: 500 });\n  }\n}\n```\n4. Create login API endpoint at app/api/login/route.ts\n5. Implement middleware for protected routes\n6. Set up NextAuth.js for session management\n7. Create protected route wrapper component",
        "testStrategy": "1. Test user registration with valid and invalid data\n2. Test login with correct and incorrect credentials\n3. Verify JWT token generation and validation\n4. Test protected routes with and without authentication\n5. Verify password hashing security\n6. Test session persistence and expiration\n7. Validate error handling for authentication failures",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Password Reset Functionality",
        "description": "Implement password reset flow with email verification",
        "details": "1. Install email service package:\n```bash\nnpm install nodemailer\nnpm install -D @types/nodemailer\n```\n2. Create email service utility in lib/email.ts:\n```typescript\nimport nodemailer from 'nodemailer';\n\nconst transporter = nodemailer.createTransport({\n  host: process.env.SMTP_HOST,\n  port: Number(process.env.SMTP_PORT),\n  secure: Boolean(process.env.SMTP_SECURE),\n  auth: {\n    user: process.env.SMTP_USER,\n    pass: process.env.SMTP_PASSWORD,\n  },\n});\n\nexport async function sendPasswordResetEmail(email: string, token: string): Promise<void> {\n  const resetUrl = `${process.env.NEXT_PUBLIC_APP_URL}/reset-password?token=${token}`;\n  \n  await transporter.sendMail({\n    from: process.env.SMTP_FROM,\n    to: email,\n    subject: 'Reset your password',\n    html: `\n      <p>You requested a password reset.</p>\n      <p>Click <a href=\"${resetUrl}\">here</a> to reset your password.</p>\n      <p>If you didn't request this, please ignore this email.</p>\n    `,\n  });\n}\n```\n3. Create forgot-password API endpoint at app/api/forgot-password/route.ts:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport { randomBytes } from 'crypto';\nimport prisma from '@/lib/db';\nimport { sendPasswordResetEmail } from '@/lib/email';\n\nconst forgotPasswordSchema = z.object({\n  email: z.string().email(),\n});\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { email } = forgotPasswordSchema.parse(body);\n    \n    const user = await prisma.user.findUnique({ where: { email } });\n    if (!user) {\n      // Return success even if user doesn't exist for security\n      return NextResponse.json({ message: 'If an account exists, a reset email has been sent' });\n    }\n    \n    const token = randomBytes(32).toString('hex');\n    const expires = new Date(Date.now() + 3600000); // 1 hour\n    \n    // Store token in database (create a PasswordReset model in Prisma)\n    await prisma.passwordReset.create({\n      data: {\n        email,\n        token,\n        expires,\n      },\n    });\n    \n    await sendPasswordResetEmail(email, token);\n    \n    return NextResponse.json({ message: 'If an account exists, a reset email has been sent' });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json({ error: error.errors }, { status: 400 });\n    }\n    return NextResponse.json({ error: 'Password reset request failed' }, { status: 500 });\n  }\n}\n```\n4. Create reset-password API endpoint at app/api/reset-password/route.ts\n5. Create password reset form components\n6. Update Prisma schema to include PasswordReset model",
        "testStrategy": "1. Test forgot password flow with valid and invalid email addresses\n2. Verify email sending functionality with test SMTP server\n3. Test password reset token validation\n4. Verify password reset with valid and invalid tokens\n5. Test token expiration handling\n6. Validate security measures against timing attacks\n7. Test error handling for all edge cases",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Note CRUD API Implementation",
        "description": "Implement API endpoints for creating, reading, updating, and deleting notes",
        "details": "1. Create notes API endpoints in app/api/notes/route.ts:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport prisma from '@/lib/db';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\nconst noteSchema = z.object({\n  title: z.string().min(1),\n  content: z.string(),\n  tags: z.array(z.string()),\n});\n\n// GET all notes\nexport async function GET(request: Request) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const { searchParams } = new URL(request.url);\n    const query = searchParams.get('query') || '';\n    const tag = searchParams.get('tag');\n    const archived = searchParams.get('archived') === 'true';\n    \n    const notes = await prisma.note.findMany({\n      where: {\n        userId: session.user.id,\n        isArchived: archived,\n        ...(tag ? { tags: { has: tag } } : {}),\n        ...(query ? {\n          OR: [\n            { title: { contains: query, mode: 'insensitive' } },\n            { content: { contains: query, mode: 'insensitive' } },\n          ],\n        } : {}),\n      },\n      orderBy: { updatedAt: 'desc' },\n    });\n    \n    return NextResponse.json(notes);\n  } catch (error) {\n    return NextResponse.json({ error: 'Failed to fetch notes' }, { status: 500 });\n  }\n}\n\n// POST create note\nexport async function POST(request: Request) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const body = await request.json();\n    const { title, content, tags } = noteSchema.parse(body);\n    \n    const note = await prisma.note.create({\n      data: {\n        title,\n        content,\n        tags,\n        userId: session.user.id,\n      },\n    });\n    \n    return NextResponse.json(note, { status: 201 });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json({ error: error.errors }, { status: 400 });\n    }\n    return NextResponse.json({ error: 'Failed to create note' }, { status: 500 });\n  }\n}\n```\n2. Create note-specific API endpoints in app/api/notes/[id]/route.ts:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport prisma from '@/lib/db';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\nconst noteUpdateSchema = z.object({\n  title: z.string().min(1).optional(),\n  content: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  isArchived: z.boolean().optional(),\n});\n\n// GET single note\nexport async function GET(request: Request, { params }: { params: { id: string } }) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const note = await prisma.note.findUnique({\n      where: { id: params.id },\n    });\n    \n    if (!note) {\n      return NextResponse.json({ error: 'Note not found' }, { status: 404 });\n    }\n    \n    if (note.userId !== session.user.id) {\n      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n    }\n    \n    return NextResponse.json(note);\n  } catch (error) {\n    return NextResponse.json({ error: 'Failed to fetch note' }, { status: 500 });\n  }\n}\n\n// PUT update note\nexport async function PUT(request: Request, { params }: { params: { id: string } }) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const note = await prisma.note.findUnique({\n      where: { id: params.id },\n    });\n    \n    if (!note) {\n      return NextResponse.json({ error: 'Note not found' }, { status: 404 });\n    }\n    \n    if (note.userId !== session.user.id) {\n      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n    }\n    \n    const body = await request.json();\n    const { title, content, tags, isArchived } = noteUpdateSchema.parse(body);\n    \n    const updatedNote = await prisma.note.update({\n      where: { id: params.id },\n      data: {\n        ...(title !== undefined ? { title } : {}),\n        ...(content !== undefined ? { content } : {}),\n        ...(tags !== undefined ? { tags } : {}),\n        ...(isArchived !== undefined ? { isArchived } : {}),\n        lastEdited: new Date(),\n      },\n    });\n    \n    return NextResponse.json(updatedNote);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json({ error: error.errors }, { status: 400 });\n    }\n    return NextResponse.json({ error: 'Failed to update note' }, { status: 500 });\n  }\n}\n\n// DELETE note\nexport async function DELETE(request: Request, { params }: { params: { id: string } }) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const note = await prisma.note.findUnique({\n      where: { id: params.id },\n    });\n    \n    if (!note) {\n      return NextResponse.json({ error: 'Note not found' }, { status: 404 });\n    }\n    \n    if (note.userId !== session.user.id) {\n      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n    }\n    \n    await prisma.note.delete({\n      where: { id: params.id },\n    });\n    \n    return NextResponse.json({ message: 'Note deleted' });\n  } catch (error) {\n    return NextResponse.json({ error: 'Failed to delete note' }, { status: 500 });\n  }\n}\n```\n3. Create archive/unarchive functionality\n4. Implement validation with Zod schemas",
        "testStrategy": "1. Test creating notes with valid and invalid data\n2. Test retrieving notes with various query parameters\n3. Test updating notes with partial data\n4. Test deleting notes\n5. Verify archive/unarchive functionality\n6. Test authorization checks for all endpoints\n7. Validate error handling for all edge cases\n8. Test performance with a large number of notes",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Search and Filtering API Implementation",
        "description": "Implement advanced search functionality with keyword matching and tag filtering",
        "details": "1. Create search API endpoint at app/api/search/route.ts:\n```typescript\nimport { NextResponse } from 'next/server';\nimport prisma from '@/lib/db';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\nexport async function GET(request: Request) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const { searchParams } = new URL(request.url);\n    const query = searchParams.get('q') || '';\n    const tags = searchParams.getAll('tag');\n    const archived = searchParams.get('archived') === 'true';\n    \n    // Build search conditions\n    const where: any = {\n      userId: session.user.id,\n      isArchived: archived,\n    };\n    \n    // Add tag filtering if tags are provided\n    if (tags.length > 0) {\n      where.tags = { hasSome: tags };\n    }\n    \n    // Add text search if query is provided\n    if (query) {\n      where.OR = [\n        { title: { contains: query, mode: 'insensitive' } },\n        { content: { contains: query, mode: 'insensitive' } },\n        { tags: { has: query } },\n      ];\n    }\n    \n    const notes = await prisma.note.findMany({\n      where,\n      orderBy: { updatedAt: 'desc' },\n    });\n    \n    // Add highlight information for search results\n    const results = notes.map(note => {\n      let highlight = null;\n      if (query && note.content.toLowerCase().includes(query.toLowerCase())) {\n        const index = note.content.toLowerCase().indexOf(query.toLowerCase());\n        const start = Math.max(0, index - 50);\n        const end = Math.min(note.content.length, index + query.length + 50);\n        highlight = note.content.substring(start, end);\n      }\n      \n      return {\n        ...note,\n        highlight,\n      };\n    });\n    \n    return NextResponse.json(results);\n  } catch (error) {\n    return NextResponse.json({ error: 'Search failed' }, { status: 500 });\n  }\n}\n```\n2. Implement tag-based filtering\n3. Create search result highlighting logic\n4. Optimize search queries for performance\n5. Add pagination support for search results",
        "testStrategy": "1. Test search functionality with various query parameters\n2. Verify tag filtering works correctly\n3. Test search result highlighting\n4. Validate case-insensitive search\n5. Test search performance with large datasets\n6. Verify pagination works correctly\n7. Test combined search and filter operations\n8. Validate error handling for malformed queries",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "User Interface Layout and Navigation",
        "description": "Create responsive layout with navigation, sidebar, and main content area",
        "details": "1. Create layout components in app/components/layout:\n```typescript\n// app/components/layout/Sidebar.tsx\nimport Link from 'next/link';\nimport { usePathname } from 'next/navigation';\n\nexport default function Sidebar() {\n  const pathname = usePathname();\n  \n  const navItems = [\n    { label: 'Dashboard', href: '/dashboard', icon: 'HomeIcon' },\n    { label: 'All Notes', href: '/notes', icon: 'DocumentTextIcon' },\n    { label: 'Archived', href: '/archived', icon: 'ArchiveBoxIcon' },\n    { label: 'Settings', href: '/settings', icon: 'CogIcon' },\n  ];\n  \n  return (\n    <aside className=\"w-64 h-screen bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 hidden md:block\">\n      <div className=\"p-6\">\n        <h1 className=\"text-2xl font-bold text-gray-800 dark:text-white\">Note App</h1>\n      </div>\n      <nav className=\"mt-6\">\n        <ul>\n          {navItems.map((item) => (\n            <li key={item.href}>\n              <Link \n                href={item.href}\n                className={`flex items-center px-6 py-3 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 ${pathname === item.href ? 'bg-gray-100 dark:bg-gray-700 font-medium' : ''}`}\n              >\n                <span>{item.label}</span>\n              </Link>\n            </li>\n          ))}\n        </ul>\n      </nav>\n    </aside>\n  );\n}\n\n// app/components/layout/Header.tsx\nimport { useTheme } from 'next-themes';\nimport Link from 'next/link';\nimport { signOut } from 'next-auth/react';\n\nexport default function Header() {\n  const { theme, setTheme } = useTheme();\n  \n  return (\n    <header className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700\">\n      <div className=\"container mx-auto px-4 py-3 flex justify-between items-center\">\n        <div className=\"md:hidden\">\n          <button className=\"text-gray-500 dark:text-gray-400\">\n            <span>Menu</span>\n          </button>\n        </div>\n        \n        <div className=\"flex items-center space-x-4\">\n          <button \n            onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}\n            className=\"p-2 rounded-md text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700\"\n          >\n            {theme === 'dark' ? 'Light Mode' : 'Dark Mode'}\n          </button>\n          \n          <div className=\"relative\">\n            <button className=\"flex items-center space-x-1 text-gray-700 dark:text-gray-300\">\n              <span>Account</span>\n            </button>\n            {/* Dropdown menu */}\n          </div>\n        </div>\n      </div>\n    </header>\n  );\n}\n\n// app/layout.tsx\nimport { Inter } from 'next/font/google';\nimport './globals.css';\nimport { ThemeProvider } from '@/components/theme-provider';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport default async function RootLayout({ children }) {\n  const session = await getServerSession(authOptions);\n  \n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body className={inter.className}>\n        <ThemeProvider attribute=\"class\" defaultTheme=\"system\" enableSystem>\n          {children}\n        </ThemeProvider>\n      </body>\n    </html>\n  );\n}\n```\n2. Create theme provider component for light/dark mode\n3. Implement responsive design with Tailwind CSS\n4. Create mobile navigation menu\n5. Add keyboard navigation support\n6. Implement layout for authenticated and unauthenticated states",
        "testStrategy": "1. Test responsive layout on different screen sizes\n2. Verify theme switching functionality\n3. Test keyboard navigation accessibility\n4. Validate mobile menu functionality\n5. Test layout rendering for authenticated and unauthenticated users\n6. Verify navigation between different sections\n7. Test focus states and accessibility compliance\n8. Validate layout with different content lengths",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Authentication UI Components",
        "description": "Create user interface components for registration, login, and password reset",
        "details": "1. Create authentication components in app/components/auth:\n```typescript\n// app/components/auth/LoginForm.tsx\n'use client';\n\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { signIn } from 'next-auth/react';\nimport Link from 'next/link';\nimport { z } from 'zod';\n\nconst loginSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n});\n\nexport default function LoginForm() {\n  const router = useRouter();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  const [isLoading, setIsLoading] = useState(false);\n  const [loginError, setLoginError] = useState('');\n  \n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setErrors({});\n    setLoginError('');\n    \n    try {\n      // Validate form data\n      loginSchema.parse({ email, password });\n      \n      setIsLoading(true);\n      const result = await signIn('credentials', {\n        redirect: false,\n        email,\n        password,\n      });\n      \n      if (result?.error) {\n        setLoginError('Invalid email or password');\n        return;\n      }\n      \n      router.push('/dashboard');\n      router.refresh();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const fieldErrors: Record<string, string> = {};\n        error.errors.forEach((err) => {\n          if (err.path) {\n            fieldErrors[err.path[0]] = err.message;\n          }\n        });\n        setErrors(fieldErrors);\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <div className=\"max-w-md w-full mx-auto p-6 bg-white dark:bg-gray-800 rounded-lg shadow-md\">\n      <h2 className=\"text-2xl font-bold text-center text-gray-800 dark:text-white mb-6\">Log in to your account</h2>\n      \n      {loginError && (\n        <div className=\"mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded\">\n          {loginError}\n        </div>\n      )}\n      \n      <form onSubmit={handleSubmit}>\n        <div className=\"mb-4\">\n          <label htmlFor=\"email\" className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">Email</label>\n          <input\n            id=\"email\"\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            className=\"w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white\"\n            required\n          />\n          {errors.email && <p className=\"mt-1 text-sm text-red-600\">{errors.email}</p>}\n        </div>\n        \n        <div className=\"mb-6\">\n          <label htmlFor=\"password\" className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">Password</label>\n          <input\n            id=\"password\"\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            className=\"w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white\"\n            required\n          />\n          {errors.password && <p className=\"mt-1 text-sm text-red-600\">{errors.password}</p>}\n          <div className=\"mt-2 text-right\">\n            <Link href=\"/forgot-password\" className=\"text-sm text-blue-600 hover:underline dark:text-blue-400\">\n              Forgot password?\n            </Link>\n          </div>\n        </div>\n        \n        <button\n          type=\"submit\"\n          disabled={isLoading}\n          className=\"w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed\"\n        >\n          {isLoading ? 'Logging in...' : 'Log in'}\n        </button>\n      </form>\n      \n      <div className=\"mt-6 text-center\">\n        <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n          Don't have an account?{' '}\n          <Link href=\"/register\" className=\"text-blue-600 hover:underline dark:text-blue-400\">\n            Sign up\n          </Link>\n        </p>\n      </div>\n    </div>\n  );\n}\n```\n2. Create RegisterForm component\n3. Create ForgotPasswordForm component\n4. Create ResetPasswordForm component\n5. Implement form validation with Zod\n6. Add loading states and error handling\n7. Create authentication page layouts",
        "testStrategy": "1. Test form validation for all authentication forms\n2. Verify error message display for invalid inputs\n3. Test form submission with valid and invalid data\n4. Validate loading states during form submission\n5. Test navigation between authentication pages\n6. Verify password reset flow end-to-end\n7. Test form accessibility with keyboard navigation\n8. Validate responsive design on different screen sizes",
        "priority": "high",
        "dependencies": [
          3,
          4,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Note Editor Component with Rich Text Support",
        "description": "Implement WYSIWYG rich text editor for note creation and editing",
        "details": "1. Install rich text editor package:\n```bash\nnpm install @tiptap/react @tiptap/starter-kit @tiptap/extension-placeholder @tiptap/extension-image\n```\n2. Create rich text editor component in app/components/notes/Editor.tsx:\n```typescript\n'use client';\n\nimport { useEditor, EditorContent } from '@tiptap/react';\nimport StarterKit from '@tiptap/starter-kit';\nimport Placeholder from '@tiptap/extension-placeholder';\nimport Image from '@tiptap/extension-image';\nimport { useState, useEffect, useCallback } from 'react';\nimport { debounce } from 'lodash';\n\ninterface EditorProps {\n  initialContent: string;\n  onUpdate: (content: string) => void;\n  placeholder?: string;\n}\n\nexport default function Editor({ initialContent, onUpdate, placeholder = 'Start writing...' }: EditorProps) {\n  const [isMounted, setIsMounted] = useState(false);\n  \n  const editor = useEditor({\n    extensions: [\n      StarterKit,\n      Placeholder.configure({\n        placeholder,\n      }),\n      Image,\n    ],\n    content: initialContent,\n    editorProps: {\n      attributes: {\n        class: 'prose dark:prose-invert prose-sm sm:prose-base lg:prose-lg xl:prose-xl focus:outline-none max-w-none',\n      },\n    },\n    onUpdate: ({ editor }) => {\n      const html = editor.getHTML();\n      debouncedUpdate(html);\n    },\n  });\n  \n  // Debounce the update function to avoid too many API calls\n  const debouncedUpdate = useCallback(\n    debounce((content: string) => {\n      onUpdate(content);\n    }, 750),\n    [onUpdate]\n  );\n  \n  useEffect(() => {\n    setIsMounted(true);\n  }, []);\n  \n  if (!isMounted) {\n    return null;\n  }\n  \n  return (\n    <div className=\"border border-gray-200 dark:border-gray-700 rounded-md\">\n      <div className=\"flex items-center border-b border-gray-200 dark:border-gray-700 p-2\">\n        {editor && (\n          <div className=\"flex space-x-2\">\n            <button\n              onClick={() => editor.chain().focus().toggleBold().run()}\n              className={`p-1 rounded ${editor.isActive('bold') ? 'bg-gray-200 dark:bg-gray-700' : ''}`}\n              aria-label=\"Bold\"\n            >\n              B\n            </button>\n            <button\n              onClick={() => editor.chain().focus().toggleItalic().run()}\n              className={`p-1 rounded ${editor.isActive('italic') ? 'bg-gray-200 dark:bg-gray-700' : ''}`}\n              aria-label=\"Italic\"\n            >\n              I\n            </button>\n            <button\n              onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}\n              className={`p-1 rounded ${editor.isActive('heading', { level: 2 }) ? 'bg-gray-200 dark:bg-gray-700' : ''}`}\n              aria-label=\"Heading\"\n            >\n              H\n            </button>\n            <button\n              onClick={() => editor.chain().focus().toggleBulletList().run()}\n              className={`p-1 rounded ${editor.isActive('bulletList') ? 'bg-gray-200 dark:bg-gray-700' : ''}`}\n              aria-label=\"Bullet List\"\n            >\n              â€¢\n            </button>\n            <button\n              onClick={() => editor.chain().focus().toggleOrderedList().run()}\n              className={`p-1 rounded ${editor.isActive('orderedList') ? 'bg-gray-200 dark:bg-gray-700' : ''}`}\n              aria-label=\"Ordered List\"\n            >\n              1.\n            </button>\n          </div>\n        )}\n      </div>\n      <EditorContent editor={editor} className=\"p-4 min-h-[200px]\" />\n    </div>\n  );\n}\n```\n3. Create note editor container component in app/components/notes/NoteEditor.tsx:\n```typescript\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport Editor from './Editor';\nimport TagInput from './TagInput';\n\ninterface Note {\n  id?: string;\n  title: string;\n  content: string;\n  tags: string[];\n  isArchived?: boolean;\n}\n\ninterface NoteEditorProps {\n  note?: Note;\n  isNew?: boolean;\n}\n\nexport default function NoteEditor({ note, isNew = false }: NoteEditorProps) {\n  const router = useRouter();\n  const [title, setTitle] = useState(note?.title || '');\n  const [content, setContent] = useState(note?.content || '');\n  const [tags, setTags] = useState<string[]>(note?.tags || []);\n  const [isSaving, setIsSaving] = useState(false);\n  const [saveStatus, setSaveStatus] = useState('');\n  \n  // Auto-save functionality\n  useEffect(() => {\n    if (!isNew && note?.id && (title !== note.title || content !== note.content || tags !== note.tags)) {\n      const timer = setTimeout(() => {\n        saveNote();\n      }, 1000);\n      \n      return () => clearTimeout(timer);\n    }\n  }, [title, content, tags]);\n  \n  const saveNote = async () => {\n    if (!title.trim()) return;\n    \n    setIsSaving(true);\n    setSaveStatus('Saving...');\n    \n    try {\n      const endpoint = isNew ? '/api/notes' : `/api/notes/${note?.id}`;\n      const method = isNew ? 'POST' : 'PUT';\n      \n      const response = await fetch(endpoint, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          title,\n          content,\n          tags,\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to save note');\n      }\n      \n      const savedNote = await response.json();\n      \n      setSaveStatus('Saved');\n      \n      if (isNew) {\n        router.push(`/notes/${savedNote.id}`);\n      }\n    } catch (error) {\n      setSaveStatus('Failed to save');\n    } finally {\n      setIsSaving(false);\n      setTimeout(() => setSaveStatus(''), 3000);\n    }\n  };\n  \n  const handleArchive = async () => {\n    if (!note?.id) return;\n    \n    try {\n      const response = await fetch(`/api/notes/${note.id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          isArchived: !note.isArchived,\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to archive note');\n      }\n      \n      router.refresh();\n      router.push('/notes');\n    } catch (error) {\n      console.error('Error archiving note:', error);\n    }\n  };\n  \n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <input\n          type=\"text\"\n          value={title}\n          onChange={(e) => setTitle(e.target.value)}\n          placeholder=\"Note title\"\n          className=\"text-2xl font-bold w-full bg-transparent border-none focus:outline-none focus:ring-0\"\n        />\n        \n        <div className=\"flex items-center space-x-2 text-sm\">\n          {saveStatus && (\n            <span className=\"text-gray-500 dark:text-gray-400\">{saveStatus}</span>\n          )}\n          \n          {!isNew && (\n            <button\n              onClick={handleArchive}\n              className=\"px-3 py-1 text-sm rounded-md bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600\"\n            >\n              {note?.isArchived ? 'Unarchive' : 'Archive'}\n            </button>\n          )}\n          \n          <button\n            onClick={saveNote}\n            disabled={isSaving || !title.trim()}\n            className=\"px-3 py-1 text-sm rounded-md bg-blue-600 hover:bg-blue-700 text-white disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            {isSaving ? 'Saving...' : 'Save'}\n          </button>\n        </div>\n      </div>\n      \n      <TagInput tags={tags} onChange={setTags} />\n      \n      <Editor initialContent={content} onUpdate={setContent} />\n    </div>\n  );\n}\n```\n4. Create TagInput component for tag management\n5. Implement auto-save functionality with debouncing\n6. Add keyboard shortcuts for common editor actions",
        "testStrategy": "1. Test rich text editor functionality (bold, italic, lists, etc.)\n2. Verify auto-save functionality with debouncing\n3. Test tag input component for adding and removing tags\n4. Validate keyboard shortcuts for editor actions\n5. Test content persistence between editor sessions\n6. Verify editor responsiveness on different screen sizes\n7. Test accessibility of editor controls\n8. Validate error handling during save operations",
        "priority": "high",
        "dependencies": [
          5,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Note List and Dashboard UI",
        "description": "Create note listing, dashboard, and note detail views",
        "details": "1. Create note list component in app/components/notes/NoteList.tsx:\n```typescript\n'use client';\n\nimport Link from 'next/link';\nimport { useState } from 'react';\n\ninterface Note {\n  id: string;\n  title: string;\n  content: string;\n  tags: string[];\n  isArchived: boolean;\n  createdAt: string;\n  updatedAt: string;\n  highlight?: string | null;\n}\n\ninterface NoteListProps {\n  notes: Note[];\n  showArchived?: boolean;\n}\n\nexport default function NoteList({ notes, showArchived = false }: NoteListProps) {\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedTag, setSelectedTag] = useState<string | null>(null);\n  \n  // Get all unique tags from notes\n  const allTags = Array.from(new Set(notes.flatMap(note => note.tags)));\n  \n  // Filter notes based on search query and selected tag\n  const filteredNotes = notes.filter(note => {\n    const matchesSearch = searchQuery === '' || \n      note.title.toLowerCase().includes(searchQuery.toLowerCase()) || \n      note.content.toLowerCase().includes(searchQuery.toLowerCase());\n    \n    const matchesTag = selectedTag === null || note.tags.includes(selectedTag);\n    \n    return matchesSearch && matchesTag;\n  });\n  \n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4\">\n        <div className=\"relative\">\n          <input\n            type=\"text\"\n            placeholder=\"Search notes...\"\n            value={searchQuery}\n            onChange={(e) => setSearchQuery(e.target.value)}\n            className=\"w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white\"\n          />\n        </div>\n        \n        <Link\n          href=\"/notes/new\"\n          className=\"px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md inline-flex items-center justify-center\"\n        >\n          New Note\n        </Link>\n      </div>\n      \n      {allTags.length > 0 && (\n        <div className=\"flex flex-wrap gap-2\">\n          <button\n            onClick={() => setSelectedTag(null)}\n            className={`px-3 py-1 text-sm rounded-full ${selectedTag === null ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200' : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200'}`}\n          >\n            All\n          </button>\n          {allTags.map(tag => (\n            <button\n              key={tag}\n              onClick={() => setSelectedTag(tag === selectedTag ? null : tag)}\n              className={`px-3 py-1 text-sm rounded-full ${tag === selectedTag ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200' : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200'}`}\n            >\n              {tag}\n            </button>\n          ))}\n        </div>\n      )}\n      \n      {filteredNotes.length === 0 ? (\n        <div className=\"text-center py-12\">\n          <p className=\"text-gray-500 dark:text-gray-400\">\n            {searchQuery || selectedTag ? 'No notes match your search' : 'No notes yet'}\n          </p>\n          {!searchQuery && !selectedTag && (\n            <Link\n              href=\"/notes/new\"\n              className=\"mt-4 inline-block px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md\"\n            >\n              Create your first note\n            </Link>\n          )}\n        </div>\n      ) : (\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n          {filteredNotes.map(note => (\n            <Link\n              key={note.id}\n              href={`/notes/${note.id}`}\n              className=\"block p-4 border border-gray-200 dark:border-gray-700 rounded-lg hover:shadow-md transition-shadow\"\n            >\n              <h3 className=\"text-lg font-medium text-gray-900 dark:text-white truncate\">{note.title}</h3>\n              \n              {note.tags.length > 0 && (\n                <div className=\"flex flex-wrap gap-1 mt-2\">\n                  {note.tags.map(tag => (\n                    <span key={tag} className=\"px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200\">\n                      {tag}\n                    </span>\n                  ))}\n                </div>\n              )}\n              \n              <div className=\"mt-2 text-sm text-gray-500 dark:text-gray-400 line-clamp-3\">\n                {note.highlight ? (\n                  <p dangerouslySetInnerHTML={{ __html: `...${note.highlight}...` }} />\n                ) : (\n                  <p>{note.content.replace(/<[^>]*>/g, '').substring(0, 150)}...</p>\n                )}\n              </div>\n              \n              <div className=\"mt-4 text-xs text-gray-500 dark:text-gray-400\">\n                {new Date(note.updatedAt).toLocaleDateString()}\n              </div>\n            </Link>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n2. Create dashboard page in app/dashboard/page.tsx\n3. Create notes listing page in app/notes/page.tsx\n4. Create note detail page in app/notes/[id]/page.tsx\n5. Create new note page in app/notes/new/page.tsx\n6. Create archived notes page in app/archived/page.tsx\n7. Implement client-side filtering and searching",
        "testStrategy": "1. Test note list rendering with various data sets\n2. Verify search functionality within the note list\n3. Test tag filtering in the note list\n4. Validate note card display with different content lengths\n5. Test navigation between list and detail views\n6. Verify empty state handling\n7. Test responsive layout on different screen sizes\n8. Validate highlight rendering in search results",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Theme and Font Customization",
        "description": "Implement theme switching (light/dark) and font customization options",
        "details": "1. Create theme provider component in app/components/theme-provider.tsx:\n```typescript\n'use client';\n\nimport { createContext, useContext, useEffect, useState } from 'react';\n\ntype Theme = 'light' | 'dark' | 'system';\ntype Font = 'sans' | 'serif' | 'mono';\n\ninterface ThemeProviderProps {\n  children: React.ReactNode;\n  defaultTheme?: Theme;\n  defaultFont?: Font;\n  enableSystem?: boolean;\n  attribute?: string;\n}\n\ntype ThemeProviderState = {\n  theme: Theme;\n  font: Font;\n  setTheme: (theme: Theme) => void;\n  setFont: (font: Font) => void;\n};\n\nconst initialState: ThemeProviderState = {\n  theme: 'system',\n  font: 'sans',\n  setTheme: () => null,\n  setFont: () => null,\n};\n\nconst ThemeProviderContext = createContext<ThemeProviderState>(initialState);\n\nexport function ThemeProvider({\n  children,\n  defaultTheme = 'system',\n  defaultFont = 'sans',\n  enableSystem = true,\n  attribute = 'class',\n  ...props\n}: ThemeProviderProps) {\n  const [theme, setTheme] = useState<Theme>(defaultTheme);\n  const [font, setFont] = useState<Font>(defaultFont);\n  \n  useEffect(() => {\n    const root = window.document.documentElement;\n    \n    // Remove previous font class\n    root.classList.remove('font-sans', 'font-serif', 'font-mono');\n    \n    // Add current font class\n    root.classList.add(`font-${font}`);\n    \n    // Handle theme\n    root.classList.remove('light', 'dark');\n    \n    if (theme === 'system' && enableSystem) {\n      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches\n        ? 'dark'\n        : 'light';\n      \n      root.classList.add(systemTheme);\n      return;\n    }\n    \n    root.classList.add(theme);\n  }, [theme, font, enableSystem]);\n  \n  const value = {\n    theme,\n    font,\n    setTheme,\n    setFont,\n  };\n  \n  return (\n    <ThemeProviderContext.Provider {...props} value={value}>\n      {children}\n    </ThemeProviderContext.Provider>\n  );\n}\n\nexport const useTheme = () => {\n  const context = useContext(ThemeProviderContext);\n  \n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  \n  return context;\n};\n```\n2. Create settings page in app/settings/page.tsx:\n```typescript\n'use client';\n\nimport { useTheme } from '@/components/theme-provider';\n\nexport default function SettingsPage() {\n  const { theme, setTheme, font, setFont } = useTheme();\n  \n  return (\n    <div className=\"container mx-auto py-8 px-4\">\n      <h1 className=\"text-2xl font-bold mb-6\">Settings</h1>\n      \n      <div className=\"space-y-8\">\n        <div>\n          <h2 className=\"text-xl font-medium mb-4\">Theme</h2>\n          <div className=\"grid grid-cols-1 sm:grid-cols-3 gap-4\">\n            <button\n              onClick={() => setTheme('light')}\n              className={`p-4 border rounded-lg flex items-center justify-center ${theme === 'light' ? 'border-blue-500 ring-2 ring-blue-500' : 'border-gray-200 dark:border-gray-700'}`}\n            >\n              <div className=\"text-center\">\n                <div className=\"w-16 h-16 rounded-full bg-gray-100 mx-auto mb-2 flex items-center justify-center\">\n                  <span>â˜€ï¸</span>\n                </div>\n                <span>Light</span>\n              </div>\n            </button>\n            \n            <button\n              onClick={() => setTheme('dark')}\n              className={`p-4 border rounded-lg flex items-center justify-center ${theme === 'dark' ? 'border-blue-500 ring-2 ring-blue-500' : 'border-gray-200 dark:border-gray-700'}`}\n            >\n              <div className=\"text-center\">\n                <div className=\"w-16 h-16 rounded-full bg-gray-800 mx-auto mb-2 flex items-center justify-center\">\n                  <span>ðŸŒ™</span>\n                </div>\n                <span>Dark</span>\n              </div>\n            </button>\n            \n            <button\n              onClick={() => setTheme('system')}\n              className={`p-4 border rounded-lg flex items-center justify-center ${theme === 'system' ? 'border-blue-500 ring-2 ring-blue-500' : 'border-gray-200 dark:border-gray-700'}`}\n            >\n              <div className=\"text-center\">\n                <div className=\"w-16 h-16 rounded-full bg-gradient-to-r from-gray-100 to-gray-800 mx-auto mb-2 flex items-center justify-center\">\n                  <span>ðŸ’»</span>\n                </div>\n                <span>System</span>\n              </div>\n            </button>\n          </div>\n        </div>\n        \n        <div>\n          <h2 className=\"text-xl font-medium mb-4\">Font</h2>\n          <div className=\"grid grid-cols-1 sm:grid-cols-3 gap-4\">\n            <button\n              onClick={() => setFont('sans')}\n              className={`p-4 border rounded-lg ${font === 'sans' ? 'border-blue-500 ring-2 ring-blue-500' : 'border-gray-200 dark:border-gray-700'}`}\n            >\n              <p className=\"font-sans text-lg mb-2\">Sans Serif</p>\n              <p className=\"font-sans text-sm text-gray-500 dark:text-gray-400\">Clean and modern</p>\n            </button>\n            \n            <button\n              onClick={() => setFont('serif')}\n              className={`p-4 border rounded-lg ${font === 'serif' ? 'border-blue-500 ring-2 ring-blue-500' : 'border-gray-200 dark:border-gray-700'}`}\n            >\n              <p className=\"font-serif text-lg mb-2\">Serif</p>\n              <p className=\"font-serif text-sm text-gray-500 dark:text-gray-400\">Traditional and elegant</p>\n            </button>\n            \n            <button\n              onClick={() => setFont('mono')}\n              className={`p-4 border rounded-lg ${font === 'mono' ? 'border-blue-500 ring-2 ring-blue-500' : 'border-gray-200 dark:border-gray-700'}`}\n            >\n              <p className=\"font-mono text-lg mb-2\">Monospace</p>\n              <p className=\"font-mono text-sm text-gray-500 dark:text-gray-400\">Code-like and precise</p>\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n3. Update Tailwind configuration to support font themes:\n```javascript\n// tailwind.config.js\nmodule.exports = {\n  darkMode: 'class',\n  content: [\n    './app/**/*.{js,ts,jsx,tsx}',\n    './components/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      fontFamily: {\n        sans: ['var(--font-sans)', 'system-ui', 'sans-serif'],\n        serif: ['var(--font-serif)', 'Georgia', 'serif'],\n        mono: ['var(--font-mono)', 'monospace'],\n      },\n    },\n  },\n  plugins: [require('@tailwindcss/typography')],\n};\n```\n4. Add font loading in layout.tsx\n5. Implement theme persistence with localStorage\n6. Add system theme detection and synchronization",
        "testStrategy": "1. Test theme switching between light, dark, and system modes\n2. Verify font switching between sans-serif, serif, and monospace\n3. Test theme persistence across page refreshes\n4. Validate system theme detection and synchronization\n5. Test theme provider with different default settings\n6. Verify theme application to all components\n7. Test accessibility of theme switching controls\n8. Validate responsive design of settings page",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Keyboard Navigation and Accessibility",
        "description": "Implement keyboard shortcuts and ensure accessibility compliance",
        "details": "1. Create keyboard shortcut utility in app/lib/keyboard.ts:\n```typescript\n'use client';\n\nimport { useEffect, useCallback } from 'react';\n\ntype KeyboardShortcut = {\n  key: string;\n  ctrlKey?: boolean;\n  shiftKey?: boolean;\n  altKey?: boolean;\n  metaKey?: boolean;\n  action: () => void;\n  preventDefault?: boolean;\n};\n\nexport function useKeyboardShortcuts(shortcuts: KeyboardShortcut[]) {\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      for (const shortcut of shortcuts) {\n        const keyMatch = event.key.toLowerCase() === shortcut.key.toLowerCase();\n        const ctrlMatch = shortcut.ctrlKey === undefined || event.ctrlKey === shortcut.ctrlKey;\n        const shiftMatch = shortcut.shiftKey === undefined || event.shiftKey === shortcut.shiftKey;\n        const altMatch = shortcut.altKey === undefined || event.altKey === shortcut.altKey;\n        const metaMatch = shortcut.metaKey === undefined || event.metaKey === shortcut.metaKey;\n        \n        if (keyMatch && ctrlMatch && shiftMatch && altMatch && metaMatch) {\n          if (shortcut.preventDefault !== false) {\n            event.preventDefault();\n          }\n          shortcut.action();\n          break;\n        }\n      }\n    },\n    [shortcuts]\n  );\n  \n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n}\n```\n2. Create accessibility components in app/components/ui:\n```typescript\n// app/components/ui/SkipLink.tsx\n'use client';\n\nexport default function SkipLink() {\n  return (\n    <a\n      href=\"#main-content\"\n      className=\"sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-blue-600 focus:text-white focus:rounded-md\"\n    >\n      Skip to main content\n    </a>\n  );\n}\n\n// app/components/ui/KeyboardShortcutHelp.tsx\n'use client';\n\nimport { useState } from 'react';\nimport { useKeyboardShortcuts } from '@/lib/keyboard';\n\nexport default function KeyboardShortcutHelp() {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  useKeyboardShortcuts([\n    {\n      key: '?',\n      shiftKey: true,\n      action: () => setIsOpen(true),\n    },\n    {\n      key: 'Escape',\n      action: () => setIsOpen(false),\n    },\n  ]);\n  \n  if (!isOpen) return null;\n  \n  const shortcuts = [\n    { keys: ['?'], description: 'Show keyboard shortcuts' },\n    { keys: ['Ctrl', 'S'], description: 'Save current note' },\n    { keys: ['Ctrl', '/'], description: 'Focus search' },\n    { keys: ['Ctrl', 'N'], description: 'Create new note' },\n    { keys: ['Esc'], description: 'Close dialogs' },\n    { keys: ['Alt', 'â†'], description: 'Go back to notes list' },\n  ];\n  \n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4\">\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-md w-full p-6\">\n        <div className=\"flex justify-between items-center mb-4\">\n          <h2 className=\"text-xl font-bold\">Keyboard Shortcuts</h2>\n          <button\n            onClick={() => setIsOpen(false)}\n            className=\"text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200\"\n            aria-label=\"Close\"\n          >\n            Ã—\n          </button>\n        </div>\n        \n        <div className=\"space-y-2\">\n          {shortcuts.map((shortcut, index) => (\n            <div key={index} className=\"flex justify-between items-center\">\n              <span>{shortcut.description}</span>\n              <div className=\"flex space-x-1\">\n                {shortcut.keys.map((key, keyIndex) => (\n                  <kbd\n                    key={keyIndex}\n                    className=\"px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded dark:bg-gray-700 dark:text-gray-200 dark:border-gray-600\"\n                  >\n                    {key}\n                  </kbd>\n                ))}\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n3. Implement keyboard shortcuts in NoteEditor component:\n```typescript\n// Add to NoteEditor.tsx\nimport { useKeyboardShortcuts } from '@/lib/keyboard';\n\n// Inside component\nuseKeyboardShortcuts([\n  {\n    key: 's',\n    ctrlKey: true,\n    action: () => saveNote(),\n  },\n  {\n    key: 'Escape',\n    action: () => router.push('/notes'),\n  },\n]);\n```\n4. Add focus management for form elements\n5. Implement ARIA attributes for interactive elements\n6. Add screen reader announcements for dynamic content\n7. Ensure proper tab order and focus indicators",
        "testStrategy": "1. Test keyboard shortcuts for all defined actions\n2. Verify focus management across the application\n3. Test screen reader compatibility with assistive technology\n4. Validate ARIA attributes on interactive elements\n5. Test tab navigation through the application\n6. Verify keyboard accessibility of all interactive components\n7. Test skip link functionality\n8. Validate color contrast for accessibility compliance",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Real-time Collaborative Editing",
        "description": "Implement WebSocket-based real-time collaborative editing",
        "details": "1. Install WebSocket packages:\n```bash\nnpm install socket.io socket.io-client y-websocket yjs\n```\n2. Create WebSocket server setup in app/api/socket/route.ts:\n```typescript\nimport { Server } from 'socket.io';\nimport { NextApiRequest } from 'next';\nimport { NextApiResponseServerIO } from '@/types/next';\nimport { verifyToken } from '@/lib/auth';\n\nexport default function SocketHandler(req: NextApiRequest, res: NextApiResponseServerIO) {\n  if (!res.socket.server.io) {\n    const io = new Server(res.socket.server);\n    \n    io.use((socket, next) => {\n      const token = socket.handshake.auth.token;\n      if (!token) {\n        return next(new Error('Authentication error'));\n      }\n      \n      const decoded = verifyToken(token);\n      if (!decoded) {\n        return next(new Error('Authentication error'));\n      }\n      \n      socket.data.userId = decoded.userId;\n      next();\n    });\n    \n    io.on('connection', (socket) => {\n      console.log(`User connected: ${socket.data.userId}`);\n      \n      socket.on('join-note', (noteId) => {\n        socket.join(`note:${noteId}`);\n        console.log(`User ${socket.data.userId} joined note: ${noteId}`);\n      });\n      \n      socket.on('leave-note', (noteId) => {\n        socket.leave(`note:${noteId}`);\n        console.log(`User ${socket.data.userId} left note: ${noteId}`);\n      });\n      \n      socket.on('note-update', ({ noteId, content, cursorPosition }) => {\n        socket.to(`note:${noteId}`).emit('note-updated', {\n          userId: socket.data.userId,\n          content,\n          cursorPosition,\n        });\n      });\n      \n      socket.on('disconnect', () => {\n        console.log(`User disconnected: ${socket.data.userId}`);\n      });\n    });\n    \n    res.socket.server.io = io;\n  }\n  \n  res.end();\n}\n```\n3. Create collaborative editor component in app/components/notes/CollaborativeEditor.tsx:\n```typescript\n'use client';\n\nimport { useEffect, useState, useRef } from 'react';\nimport { useEditor, EditorContent } from '@tiptap/react';\nimport StarterKit from '@tiptap/starter-kit';\nimport Collaboration from '@tiptap/extension-collaboration';\nimport CollaborationCursor from '@tiptap/extension-collaboration-cursor';\nimport { WebsocketProvider } from 'y-websocket';\nimport * as Y from 'yjs';\nimport { io, Socket } from 'socket.io-client';\n\ninterface CollaborativeEditorProps {\n  noteId: string;\n  initialContent: string;\n  token: string;\n  username: string;\n}\n\nexport default function CollaborativeEditor({\n  noteId,\n  initialContent,\n  token,\n  username,\n}: CollaborativeEditorProps) {\n  const [isMounted, setIsMounted] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const [activeUsers, setActiveUsers] = useState<string[]>([]);\n  const socketRef = useRef<Socket | null>(null);\n  \n  useEffect(() => {\n    setIsMounted(true);\n    \n    // Initialize Socket.io connection\n    socketRef.current = io({\n      auth: { token },\n    });\n    \n    socketRef.current.on('connect', () => {\n      setIsConnected(true);\n      socketRef.current?.emit('join-note', noteId);\n    });\n    \n    socketRef.current.on('disconnect', () => {\n      setIsConnected(false);\n    });\n    \n    socketRef.current.on('users-update', (users: string[]) => {\n      setActiveUsers(users);\n    });\n    \n    return () => {\n      socketRef.current?.emit('leave-note', noteId);\n      socketRef.current?.disconnect();\n    };\n  }, [noteId, token]);\n  \n  // Initialize YJS document\n  const ydoc = new Y.Doc();\n  const provider = new WebsocketProvider(\n    `${process.env.NEXT_PUBLIC_WS_URL}/collaboration`,\n    noteId,\n    ydoc\n  );\n  \n  const editor = useEditor({\n    extensions: [\n      StarterKit,\n      Collaboration.configure({\n        document: ydoc,\n      }),\n      CollaborationCursor.configure({\n        provider,\n        user: {\n          name: username,\n          color: '#' + Math.floor(Math.random() * 16777215).toString(16),\n        },\n      }),\n    ],\n    content: initialContent,\n    editorProps: {\n      attributes: {\n        class: 'prose dark:prose-invert prose-sm sm:prose-base lg:prose-lg xl:prose-xl focus:outline-none max-w-none',\n      },\n    },\n    onUpdate: ({ editor }) => {\n      const html = editor.getHTML();\n      socketRef.current?.emit('note-update', {\n        noteId,\n        content: html,\n      });\n    },\n  });\n  \n  if (!isMounted) {\n    return null;\n  }\n  \n  return (\n    <div className=\"border border-gray-200 dark:border-gray-700 rounded-md\">\n      <div className=\"flex items-center justify-between border-b border-gray-200 dark:border-gray-700 p-2\">\n        <div className=\"flex space-x-2\">\n          {/* Editor toolbar */}\n        </div>\n        \n        <div className=\"flex items-center space-x-2\">\n          <span className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`}></span>\n          <span className=\"text-sm text-gray-500 dark:text-gray-400\">\n            {isConnected ? 'Connected' : 'Disconnected'}\n          </span>\n          \n          {activeUsers.length > 0 && (\n            <div className=\"flex -space-x-2\">\n              {activeUsers.map((user, index) => (\n                <div \n                  key={index}\n                  className=\"w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs\"\n                  title={user}\n                >\n                  {user.charAt(0).toUpperCase()}\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </div>\n      \n      <EditorContent editor={editor} className=\"p-4 min-h-[200px]\" />\n    </div>\n  );\n}\n```\n4. Update NoteEditor to support collaborative editing\n5. Implement user presence indicators\n6. Add cursor position synchronization\n7. Handle conflict resolution for concurrent edits",
        "testStrategy": "1. Test real-time synchronization between multiple clients\n2. Verify cursor position tracking across clients\n3. Test user presence indicators\n4. Validate conflict resolution for concurrent edits\n5. Test connection and reconnection handling\n6. Verify authentication for WebSocket connections\n7. Test performance with multiple simultaneous users\n8. Validate error handling for connection issues",
        "priority": "low",
        "dependencies": [
          3,
          5,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Image Upload and Storage",
        "description": "Implement image upload functionality with S3-compatible storage",
        "details": "1. Install required packages:\n```bash\nnpm install @aws-sdk/client-s3 multer next-connect uuid\nnpm install -D @types/multer @types/uuid\n```\n2. Create S3 client utility in app/lib/s3.ts:\n```typescript\nimport { S3Client, PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';\n\nconst s3Client = new S3Client({\n  region: process.env.AWS_REGION || 'us-east-1',\n  endpoint: process.env.S3_ENDPOINT,\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',\n  },\n  forcePathStyle: true, // Required for MinIO, optional for AWS S3\n});\n\nexport async function uploadFile(file: Buffer, key: string, contentType: string): Promise<string> {\n  const command = new PutObjectCommand({\n    Bucket: process.env.S3_BUCKET_NAME,\n    Key: key,\n    Body: file,\n    ContentType: contentType,\n    ACL: 'public-read',\n  });\n  \n  await s3Client.send(command);\n  \n  return `${process.env.S3_PUBLIC_URL}/${key}`;\n}\n\nexport async function deleteFile(key: string): Promise<void> {\n  const command = new DeleteObjectCommand({\n    Bucket: process.env.S3_BUCKET_NAME,\n    Key: key,\n  });\n  \n  await s3Client.send(command);\n}\n```\n3. Create image upload API endpoint in app/api/upload/route.ts:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { uploadFile } from '@/lib/s3';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport async function POST(request: Request) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const formData = await request.formData();\n    const file = formData.get('file') as File;\n    \n    if (!file) {\n      return NextResponse.json({ error: 'No file provided' }, { status: 400 });\n    }\n    \n    // Validate file type\n    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\n    if (!allowedTypes.includes(file.type)) {\n      return NextResponse.json({ error: 'Invalid file type' }, { status: 400 });\n    }\n    \n    // Validate file size (max 5MB)\n    if (file.size > 5 * 1024 * 1024) {\n      return NextResponse.json({ error: 'File too large (max 5MB)' }, { status: 400 });\n    }\n    \n    const buffer = Buffer.from(await file.arrayBuffer());\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${session.user.id}/${uuidv4()}.${fileExtension}`;\n    \n    const url = await uploadFile(buffer, fileName, file.type);\n    \n    return NextResponse.json({ url }, { status: 201 });\n  } catch (error) {\n    console.error('Upload error:', error);\n    return NextResponse.json({ error: 'Upload failed' }, { status: 500 });\n  }\n}\n```\n4. Create image upload component in app/components/notes/ImageUpload.tsx:\n```typescript\n'use client';\n\nimport { useState, useRef } from 'react';\n\ninterface ImageUploadProps {\n  onImageUploaded: (url: string) => void;\n}\n\nexport default function ImageUpload({ onImageUploaded }: ImageUploadProps) {\n  const [isUploading, setIsUploading] = useState(false);\n  const [uploadProgress, setUploadProgress] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  \n  const handleUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n    \n    setIsUploading(true);\n    setUploadProgress(0);\n    setError(null);\n    \n    const formData = new FormData();\n    formData.append('file', file);\n    \n    try {\n      // Simulate upload progress\n      const progressInterval = setInterval(() => {\n        setUploadProgress(prev => Math.min(prev + 10, 90));\n      }, 100);\n      \n      const response = await fetch('/api/upload', {\n        method: 'POST',\n        body: formData,\n      });\n      \n      clearInterval(progressInterval);\n      \n      if (!response.ok) {\n        const data = await response.json();\n        throw new Error(data.error || 'Upload failed');\n      }\n      \n      setUploadProgress(100);\n      \n      const { url } = await response.json();\n      onImageUploaded(url);\n      \n      // Reset the file input\n      if (fileInputRef.current) {\n        fileInputRef.current.value = '';\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Upload failed');\n    } finally {\n      setIsUploading(false);\n    }\n  };\n  \n  return (\n    <div>\n      <input\n        type=\"file\"\n        accept=\"image/*\"\n        onChange={handleUpload}\n        disabled={isUploading}\n        className=\"hidden\"\n        ref={fileInputRef}\n        id=\"image-upload\"\n      />\n      \n      <label\n        htmlFor=\"image-upload\"\n        className=\"inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-200 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed\"\n      >\n        {isUploading ? 'Uploading...' : 'Upload Image'}\n      </label>\n      \n      {isUploading && (\n        <div className=\"mt-2\">\n          <div className=\"w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5\">\n            <div\n              className=\"bg-blue-600 h-2.5 rounded-full\"\n              style={{ width: `${uploadProgress}%` }}\n            ></div>\n          </div>\n          <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">\n            {uploadProgress}% uploaded\n          </p>\n        </div>\n      )}\n      \n      {error && (\n        <p className=\"mt-2 text-sm text-red-600 dark:text-red-400\">{error}</p>\n      )}\n    </div>\n  );\n}\n```\n5. Integrate image upload with rich text editor\n6. Add image preview and deletion functionality\n7. Implement image optimization for different device sizes",
        "testStrategy": "1. Test image upload with valid and invalid file types\n2. Verify file size validation\n3. Test image upload progress indication\n4. Validate error handling for upload failures\n5. Test image insertion into the rich text editor\n6. Verify image deletion functionality\n7. Test image loading performance\n8. Validate image display on different device sizes",
        "priority": "low",
        "dependencies": [
          3,
          5,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Testing and Deployment Setup",
        "description": "Set up comprehensive testing and deployment configuration",
        "details": "1. Configure Vitest for testing in vite.config.ts:\n```typescript\nimport { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    setupFiles: ['./vitest.setup.ts'],\n    globals: true,\n  },\n});\n```\n2. Create test setup file in vitest.setup.ts:\n```typescript\nimport '@testing-library/jest-dom';\nimport { vi } from 'vitest';\n\n// Mock Next.js router\nvi.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: vi.fn(),\n    replace: vi.fn(),\n    prefetch: vi.fn(),\n    back: vi.fn(),\n    forward: vi.fn(),\n    refresh: vi.fn(),\n  }),\n  usePathname: () => '/',\n  useSearchParams: () => new URLSearchParams(),\n}));\n\n// Mock next-auth\nvi.mock('next-auth/react', () => ({\n  useSession: vi.fn(() => ({\n    data: {\n      user: { id: 'test-user-id', email: 'test@example.com' },\n      expires: '2100-01-01',\n    },\n    status: 'authenticated',\n  })),\n  signIn: vi.fn(),\n  signOut: vi.fn(),\n}));\n```\n3. Create example component test in app/components/ui/Button.test.tsx:\n```typescript\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { describe, it, expect, vi } from 'vitest';\nimport Button from './Button';\n\ndescribe('Button component', () => {\n  it('renders correctly', () => {\n    render(<Button>Click me</Button>);\n    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();\n  });\n  \n  it('calls onClick handler when clicked', () => {\n    const handleClick = vi.fn();\n    render(<Button onClick={handleClick}>Click me</Button>);\n    fireEvent.click(screen.getByRole('button', { name: /click me/i }));\n    expect(handleClick).toHaveBeenCalledTimes(1);\n  });\n  \n  it('can be disabled', () => {\n    render(<Button disabled>Click me</Button>);\n    expect(screen.getByRole('button', { name: /click me/i })).toBeDisabled();\n  });\n  \n  it('renders with different variants', () => {\n    const { rerender } = render(<Button variant=\"primary\">Primary</Button>);\n    expect(screen.getByRole('button')).toHaveClass('bg-blue-600');\n    \n    rerender(<Button variant=\"secondary\">Secondary</Button>);\n    expect(screen.getByRole('button')).toHaveClass('bg-gray-200');\n    \n    rerender(<Button variant=\"danger\">Danger</Button>);\n    expect(screen.getByRole('button')).toHaveClass('bg-red-600');\n  });\n});\n```\n4. Create GitHub Actions workflow in .github/workflows/ci.yml:\n```yaml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Lint\n        run: npm run lint\n      \n      - name: Type check\n        run: npm run type-check\n      \n      - name: Run tests\n        run: npm test\n  \n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Build\n        run: npm run build\n      \n      - name: Upload build artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: build\n          path: .next\n  \n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Download build artifacts\n        uses: actions/download-artifact@v3\n        with:\n          name: build\n          path: .next\n      \n      # Add deployment steps here based on your hosting provider\n      # Example for Vercel:\n      - name: Deploy to Vercel\n        uses: amondnet/vercel-action@v20\n        with:\n          vercel-token: ${{ secrets.VERCEL_TOKEN }}\n          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}\n          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}\n          vercel-args: '--prod'\n```\n5. Create Docker production configuration in Dockerfile:\n```dockerfile\n# Build stage\nFROM node:18-alpine AS builder\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci\n\nCOPY . .\nRUN npm run build\n\n# Production stage\nFROM node:18-alpine AS runner\nWORKDIR /app\n\nENV NODE_ENV=production\n\nCOPY --from=builder /app/next.config.js ./\nCOPY --from=builder /app/public ./public\nCOPY --from=builder /app/.next ./.next\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/package.json ./package.json\n\nEXPOSE 3000\n\nCMD [\"npm\", \"start\"]\n```\n6. Create production Docker Compose configuration in docker-compose.prod.yml:\n```yaml\nversion: '3'\n\nservices:\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    restart: always\n    ports:\n      - '3000:3000'\n    env_file: .env.production\n    depends_on:\n      - db\n  \n  db:\n    image: postgres:14\n    restart: always\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    env_file: .env.production\n    environment:\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_DB: ${POSTGRES_DB}\n  \n  # Add S3-compatible storage (MinIO)\n  minio:\n    image: minio/minio\n    ports:\n      - '9000:9000'\n      - '9001:9001'\n    volumes:\n      - minio_data:/data\n    environment:\n      MINIO_ROOT_USER: ${MINIO_ROOT_USER}\n      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}\n    command: server --console-address \":9001\" /data\n\nvolumes:\n  postgres_data:\n  minio_data:\n```\n7. Create example API test in app/api/notes/notes.test.ts\n8. Create example component integration test",
        "testStrategy": "1. Test component rendering and functionality\n2. Verify API endpoint behavior with mocked database\n3. Test authentication flows\n4. Validate form submissions and error handling\n5. Test Docker build and deployment process\n6. Verify GitHub Actions workflow execution\n7. Test database migrations\n8. Validate environment configuration loading",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          5,
          7,
          9
        ],
        "status": "in-progress",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-08T06:11:37.891Z",
      "updated": "2025-09-16T07:03:24.665Z",
      "description": "Tasks for master context"
    }
  }
}